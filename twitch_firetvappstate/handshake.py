# Copyright (c) 2025 w531t4
#
# This file is licensed under the MIT License.
# See the LICENSE file in the project root for full license text.

from typing import Dict, Any
from pathlib import Path
import appdaemon.plugins.hass.hassapi as hass
# pip install adb-shell
from adb_shell.adb_device import AdbDeviceTcp
from adb_shell.auth.sign_pythonrsa import PythonRSASigner
from adb_shell.auth.keygen import keygen  # available in adb-shell

class Handshake(hass.Hass):
    """Use this to produce .key and .key.pub"""
    def initialize(self):
        """ Gather attributes from apps.yaml, otherwise set defaults """
        self.args: Dict[str, Any]
        self.out_dir = Path(self.args.get("out_dir", "/config/apps"))
        self.out_file = Path(self.args.get("out_file", "firetvappstate.key"))
        self.host = self.args.get("host")
        self.port = self.args.get("port")

        # run once, then on every change
        self.run_in(self._build, 1)

    @property
    def host(self) -> str:
        """adb host to connect to"""
        return self._host

    @host.setter
    def host(self, data) -> None:
        self._host = data

    @property
    def port(self) -> int:
        """adp port to connect to"""
        return self._port

    @port.setter
    def port(self, data) -> None:
        if isinstance(data, str):
            self._port = int(data)
        elif isinstance(data, int):
            self._port = data
        else:
            raise TypeError(f"Expecting str or int, observed={type(data)}")

    @property
    def out_dir(self) -> Path:
        """ directory in which to write a generated image into """
        return self._out_dir

    @out_dir.setter
    def out_dir(self, data: Path) -> None:
        self._out_dir = data

    @property
    def out_file(self) -> Path:
        """ Name of the file generated by the script """
        return self._out_file

    @out_file.setter
    def out_file(self, data: Path) -> None:
        self._out_file = data

    def ensure_keys(self, key_path: Path) -> tuple[Path, Path]:
        """produce pub/pri keys"""
        priv = key_path
        if key_path.suffix:
            pub = key_path.with_suffix(f"{key_path.suffix}.pub")
        else:
            pub = Path(f"{str(key_path)}.pub")
        priv.parent.mkdir(parents=True, exist_ok=True)
        if not priv.exists() or not pub.exists():
            self.log(f"Generating ADB keypair at {priv} ...", level="INFO")
            keygen(str(priv))  # creates both priv and pub
            # Tighten permissions (especially if running on Linux)
            priv.chmod(0o600)
        return priv, pub

    @staticmethod
    def load_signer(priv: Path, pub: Path) -> PythonRSASigner:
        """load pub/pri keys"""
        with open(priv, "rb") as fpriv, open(pub, "rb") as fpub:
            priv_data = fpriv.read()
            pub_data = fpub.read()
        return PythonRSASigner(pub_data, priv_data)

    def _build(self, kwargs) -> None: # pylint: disable=unused-argument
        host = self.host
        try:
            port = self.port
        except ValueError:
            self.log("PORT must be an integer (e.g., 5555).", level="ERROR")
            raise

        # key_path = Path(sys.argv[3]) if len(sys.argv) >= 4 else Path("/config/.android/adbkey")
        key_path = self.out_dir / str(self.out_file)
        priv, pub = self.ensure_keys(key_path)
        signer = self.load_signer(priv, pub)

        # Create device object
        dev = AdbDeviceTcp(host, port, default_transport_timeout_s=10.0)

        # Connect: the first time, your TV may show “Allow USB debugging?”; accept it once.
        self.log(f"Connecting to {host}:{port} using key {priv} ...", level="INFO")
        ok = dev.connect(rsa_keys=[signer], auth_timeout_s=15.0)

        if not ok:
            self.log("ADB connect returned False (auth failed or device unreachable).",
                     level="ERROR")
            raise ValueError("expected ok=True.. observed ok={ok}")
        self.log("Connected. Running a simple check (getprop ro.product.model)...",
                 level="INFO")
        out = dev.shell("getprop ro.product.model")
        self.log(f"Model: {out.strip()}", level="INFO")

        # Cleanly close the socket
        dev.close()
        self.log("Done.", level="INFO")
